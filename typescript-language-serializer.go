package main

import (
	"errors"
	"fmt"
	"time"
)

type typescriptLanguageSerializer struct {
	typesMap map[string]string
}

func newTypescriptLanguageSerializer() *typescriptLanguageSerializer {
	result := &typescriptLanguageSerializer{typesMap: make(map[string]string, 0)}

	result.typesMap["bool"] = "boolean"
	result.typesMap["int"] = "number"
	result.typesMap["string"] = "string"
	result.typesMap["double"] = "number"
	result.typesMap["float"] = "number"
	result.typesMap["char"] = "string"
	result.typesMap["byte"] = "number"
	result.typesMap["date"] = "Date"

	return result
}

func (t *typescriptLanguageSerializer) getType() languageType {
	return LanguageTypeTypescript
}

func (t *typescriptLanguageSerializer) getTypeName() string {
	return "typescript"
}

func (t *typescriptLanguageSerializer) generateCode(objects []middleware, serializerInfo *serializerInfo) ([]*generatedCode, error) {
	result := make([]*generatedCode, 0)

	for _, object := range objects {
		serialized, err := t.serializeMiddleware(object, serializerInfo)
		if err != nil {
			return nil, err
		}

		result = append(result, serialized)
	}

	return result, nil
}

func (t *typescriptLanguageSerializer) serializeMiddleware(middleware middleware, serializerInfo *serializerInfo) (*generatedCode, error) {
	if class, ok := middleware.(*class); ok {
		return t.serializeClass(class)
	}

	if enum, ok := middleware.(*enum); ok {
		return t.serializeEnum(enum)
	}

	return nil, errors.New("tried to serialize unknown middleware type")
}

func (t *typescriptLanguageSerializer) serializeDeclaration(imports []string) string {
	generatedMark := "// **********************************\n" +
		"//\tGenerated by ModelsGenerator\n//\t" +
		time.Now().Format(time.RFC3339) +
		"\n// **********************************\n\n"

	result := ""
	for _, imp := range imports {
		result += fmt.Sprintf("import { %s } from \"./%s\";\n",
			toFirstCharUpper(imp), toCamelCase(imp))
	}

	return result + generatedMark
}

func (t *typescriptLanguageSerializer) serializeClass(class *class) (*generatedCode, error) {
	serializedCode := ""
	fileName := fmt.Sprintf("%s.ts", toCamelCase(class.name))

	serializedCode += fmt.Sprintf("export class %s {\n", toFirstCharUpper(class.name))

	imports := make([]string, 0)

	for _, member := range class.dataMembers {
		if isList, listType := isList(member.memberType); isList {
			if tsType, isPrimitive := t.typesMap[listType]; isPrimitive {
				listType = tsType
			} else {
				imports = append(imports, listType)
				listType = toFirstCharUpper(listType)
			}

			serializedCode += fmt.Sprintf("\t%s: %s[];\n", toCamelCase(member.name), listType)

			continue
		}

		if isMap, mapKeyType, mapValueType := isMap(member.memberType); isMap {
			if keyPrimitiveType, isPrimitive := t.typesMap[mapKeyType]; isPrimitive {
				mapKeyType = keyPrimitiveType
			} else {
				// Not suppose to happen, but it's user's problem
				mapKeyType = toCamelCase(mapKeyType)
			}

			if valuePrimitiveType, isPrimitive := t.typesMap[mapValueType]; isPrimitive {
				mapValueType = valuePrimitiveType
			} else {
				imports = append(imports, mapValueType)
				mapValueType = toFirstCharUpper(mapValueType)
			}

			serializedCode += fmt.Sprintf("\t%s: Map<%s, %s>;\n",
				toCamelCase(member.name), mapKeyType, mapValueType)

			continue
		}

		if primitiveType, ok := t.typesMap[member.memberType]; ok {
			serializedCode += fmt.Sprintf("\t%s: %s;\n",
				toCamelCase(member.name), primitiveType)

			continue
		}

		// Normal but not primitive member
		serializedCode += fmt.Sprintf("\t%s: %s;\n",
			toCamelCase(member.name), toFirstCharUpper(member.memberType))

		imports = append(imports, member.memberType)
	}

	serializedCode += "}"

	return newGeneratedCode(fileName, t.serializeDeclaration(imports)+serializedCode), nil
}

func (t *typescriptLanguageSerializer) serializeEnum(enum *enum) (*generatedCode, error) {
	serializedCode := t.serializeDeclaration([]string{})
	fileName := fmt.Sprintf("%s.ts", enum.name)

	serializedCode += fmt.Sprintf("export enum %s {\n", toFirstCharUpper(enum.name))

	for _, value := range enum.enumValues {
		serializedCode += fmt.Sprintf("\t%s = %v,\n",
			toFirstCharUpper(value.name), value.value)
	}

	if len(enum.enumValues) > 1 {
		// Delete the last ,
		serializedCode = serializedCode[:len(serializedCode)-2]
	} else {
		// Delete the unused \n
		serializedCode = serializedCode[:len(serializedCode)-1]
	}

	serializedCode += "\n}"

	return newGeneratedCode(fileName, serializedCode), nil
}
