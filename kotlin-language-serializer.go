package main

import (
	"errors"
	"fmt"
	"strings"
	"time"
)

type kotlinLanguageSerializer struct {
	typesMap map[string]string
}

func newKotlinLanguageSerializer() *kotlinLanguageSerializer {
	result := &kotlinLanguageSerializer{typesMap: make(map[string]string, 0)}

	result.typesMap["bool"] = "Boolean"
	result.typesMap["int"] = "Int"
	result.typesMap["string"] = "String"
	result.typesMap["double"] = "Double"
	result.typesMap["float"] = "Float"
	result.typesMap["char"] = "Char"
	result.typesMap["byte"] = "Byte"
	result.typesMap["date"] = "Date"

	return result
}

func (k *kotlinLanguageSerializer) getType() languageType {
	return LanguageTypeKotlin
}

func (k *kotlinLanguageSerializer) getTypeName() string {
	return "kotlin"
}

func (k *kotlinLanguageSerializer) generateCode(objects []middleware, serializerInfo *serializerInfo) ([]*generatedCode, error) {
	result := make([]*generatedCode, 0)

	for _, object := range objects {
		serialized, err := k.serializeMiddleware(object, serializerInfo)
		if err != nil {
			return nil, err
		}

		result = append(result, serialized)
	}

	return result, nil
}

func (k *kotlinLanguageSerializer) serializeMiddleware(middleware middleware, serializerInfo *serializerInfo) (*generatedCode, error) {
	if class, ok := middleware.(*class); ok {
		return k.serializeClass(class, serializerInfo)
	}

	if enum, ok := middleware.(*enum); ok {
		return k.serializeEnum(enum, serializerInfo)
	}

	return nil, errors.New("tried to serialize unknown middleware type")
}

func (k *kotlinLanguageSerializer) serializeDeclaration(serializerInfo *serializerInfo) string {
	generatedMark := "// **********************************\n" +
		"\tGenerated by ModelsGenerator\n\t" +
		time.Now().Format(time.RFC3339) +
		"\n// **********************************\n\n"

	if serializerInfo.packageName == "" {
		return generatedMark
	}

	return fmt.Sprintf("package %s\n\n", serializerInfo.packageName) + generatedMark
}

func (k *kotlinLanguageSerializer) serializeClass(class *class, serializerInfo *serializerInfo) (*generatedCode, error) {
	serializedCode := k.serializeDeclaration(serializerInfo)
	fileName := fmt.Sprintf("%s.kt", class.name)

	serializedCode += fmt.Sprintf("data class %s(", toFirstCharUpper(class.name))

	for _, member := range class.dataMembers {
		if isList, listType := isList(member.memberType); isList {
			serializedCode += fmt.Sprintf("val %s: List<%s>, ",
				toCamelCase(member.name), listType)
			continue
		}

		if isMap, mapKeyType, mapValueType := isMap(member.memberType); isMap {
			serializedCode += fmt.Sprintf("val %s: HashMap<%s, %s>, ", toCamelCase(member.name),
				toFirstCharUpper(mapKeyType), toFirstCharUpper(mapValueType))
			continue
		}

		if primitiveType, ok := k.typesMap[member.memberType]; ok {
			serializedCode += fmt.Sprintf("val %s: %s, ",
				toCamelCase(member.name), toFirstCharUpper(primitiveType))
			continue
		}

		// It's not a language type, so we create it as a pointer
		serializedCode += fmt.Sprintf("val %s: %s, ",
			toCamelCase(member.name), toFirstCharUpper(member.memberType))
	}

	// Delete the last ", "
	serializedCode = serializedCode[:len(serializedCode)-2]

	serializedCode += ")"

	return newGeneratedCode(fileName, serializedCode), nil
}

func (k *kotlinLanguageSerializer) serializeEnum(enum *enum, serializerInfo *serializerInfo) (*generatedCode, error) {
	serializedCode := k.serializeDeclaration(serializerInfo)
	fileName := fmt.Sprintf("%s.kt", enum.name)

	serializedCode += fmt.Sprintf("enum class %s(val value: Int) {\n", toFirstCharUpper(enum.name))

	for i, value := range enum.enumValues {
		serializedCode += fmt.Sprintf("\t%s(%v)", strings.ToUpper(value.name), value.value)

		if i < len(enum.enumValues)-1 {
			serializedCode += ",\n"
		} else {
			serializedCode += "\n"
		}
	}

	serializedCode += "}"

	return newGeneratedCode(fileName, serializedCode), nil
}
