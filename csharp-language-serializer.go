package main

import (
	"errors"
	"fmt"
	"time"
)

type csharpLanguageSerializer struct {
	typesMap map[string]string
}

func newCsharpLanguageSerializer() *csharpLanguageSerializer {
	result := &csharpLanguageSerializer{typesMap: make(map[string]string, 0)}

	result.typesMap["bool"] = "bool"
	result.typesMap["int"] = "int"
	result.typesMap["string"] = "string"
	result.typesMap["double"] = "double"
	result.typesMap["float"] = "float"
	result.typesMap["char"] = "char"
	result.typesMap["byte"] = "byte"
	result.typesMap["date"] = "DateTime"

	return result
}

func (c *csharpLanguageSerializer) getType() languageType {
	return LanguageTypeCSharp
}

func (c *csharpLanguageSerializer) getTypeName() string {
	return "c#"
}

func (c *csharpLanguageSerializer) generateCode(objects []middleware, serializerInfo *serializerInfo) ([]*generatedCode, error) {
	result := make([]*generatedCode, 0)

	for _, object := range objects {
		serialized, err := c.serializeMiddleware(object, serializerInfo)
		if err != nil {
			return nil, err
		}

		result = append(result, serialized)
	}

	return result, nil
}

func (c *csharpLanguageSerializer) serializeMiddleware(middleware middleware, serializerInfo *serializerInfo) (*generatedCode, error) {
	if class, ok := middleware.(*class); ok {
		return c.serializeClass(class, serializerInfo)
	}

	if enum, ok := middleware.(*enum); ok {
		return c.serializeEnum(enum, serializerInfo)
	}

	return nil, errors.New("tried to serialize unknown middleware type")
}

func (c *csharpLanguageSerializer) serializeDeclaration(imports []string, serializerInfo *serializerInfo) string {
	startNewLine := ""
	if len(imports) > 0 {
		startNewLine = "\n"
	}

	generatedMark := startNewLine + "// **********************************\n" +
		"//\tGenerated by ModelsGenerator\n//\t" +
		time.Now().Format(time.RFC3339) +
		"\n// **********************************\n\n"

	using := ""
	for _, imp := range imports {
		using += fmt.Sprintf("using %s;\n",
			imp)
	}

	// In C# you must have namespace
	namespace := fmt.Sprintf("namespace %s\n{\n", serializerInfo.packageName)

	return using + generatedMark + namespace
}

func (c *csharpLanguageSerializer) serializeClass(class *class, serializerInfo *serializerInfo) (*generatedCode, error) {
	serializedCode := ""
	fileName := fmt.Sprintf("%s.cs", toCamelCase(class.name))

	serializedCode += fmt.Sprintf("\tpublic class %s\n\t{\n", toFirstCharUpper(class.name))

	imports := []string{"Newtonsoft.Json"}

	for _, member := range class.dataMembers {
		if isList, listType := isList(member.memberType); isList {
			if tsType, isPrimitive := c.typesMap[listType]; isPrimitive {
				listType = tsType
			} else {
				listType = toFirstCharUpper(listType)
			}

			imports = appendUnique(imports, "System.Collections.Generic")

			serializedCode += fmt.Sprintf("\t\t[JsonProperty(PropertyName = \"%s\")]\n",
				toCamelCase(member.name))
			serializedCode += fmt.Sprintf("\t\tpublic List<%s> %s { get; set; }\n",
				listType, toFirstCharUpper(member.name))

			continue
		}

		if isMap, mapKeyType, mapValueType := isMap(member.memberType); isMap {
			if keyPrimitiveType, isPrimitive := c.typesMap[mapKeyType]; isPrimitive {
				mapKeyType = keyPrimitiveType
			} else {
				// Not suppose to happen, but it's user's problem
				mapKeyType = toFirstCharUpper(mapKeyType)
			}

			if valuePrimitiveType, isPrimitive := c.typesMap[mapValueType]; isPrimitive {
				mapValueType = valuePrimitiveType
			} else {
				mapValueType = toFirstCharUpper(mapValueType)
			}

			imports = appendUnique(imports, "System.Collections.Generic")

			serializedCode += fmt.Sprintf("\t\t[JsonProperty(PropertyName = \"%s\")]\n",
				toCamelCase(member.name))
			serializedCode += fmt.Sprintf("\t\tpublic Dictionary<%s, %s> %s { get; set; }\n",
				mapKeyType, mapValueType, toFirstCharUpper(member.name))

			continue
		}

		if primitiveType, ok := c.typesMap[member.memberType]; ok {
			serializedCode += fmt.Sprintf("\t\t[JsonProperty(PropertyName = \"%s\")]\n",
				toCamelCase(member.name))
			serializedCode += fmt.Sprintf("\t\tpublic %s %s { get; set; }\n",
				primitiveType, toFirstCharUpper(member.name))

			continue
		}

		// Normal but not primitive member
		serializedCode += fmt.Sprintf("\t\t[JsonProperty(PropertyName = \"%s\")]\n",
			toCamelCase(member.name))
		serializedCode += fmt.Sprintf("\t\tpublic %s %s { get; set; }\n",
			toFirstCharUpper(member.memberType), toFirstCharUpper(member.name))
	}

	serializedCode += "\t}\n}"

	return newGeneratedCode(fileName, c.serializeDeclaration(imports, serializerInfo)+serializedCode), nil
}

func (c *csharpLanguageSerializer) serializeEnum(enum *enum, serializerInfo *serializerInfo) (*generatedCode, error) {
	serializedCode := c.serializeDeclaration([]string{}, serializerInfo)
	fileName := fmt.Sprintf("%s.cs", enum.name)

	serializedCode += fmt.Sprintf("\tpublic enum %s\n\t{\n", toFirstCharUpper(enum.name))

	for _, value := range enum.enumValues {
		serializedCode += fmt.Sprintf("\t\t%s = %v,\n",
			toFirstCharUpper(value.name), value.value)
	}

	if len(enum.enumValues) > 1 {
		// Delete the last ,
		serializedCode = serializedCode[:len(serializedCode)-2]
	} else {
		// Delete the unused \n
		serializedCode = serializedCode[:len(serializedCode)-1]
	}

	serializedCode += "\n\t}\n}"

	return newGeneratedCode(fileName, serializedCode), nil
}
